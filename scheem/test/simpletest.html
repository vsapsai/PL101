<html>
<head>
  <meta charset="utf-8">
  <title>Mocha Tests</title>
  <link rel="stylesheet"
    href="http://nathansuniversity.com/css/mocha.css" />
  <script src=
    "http://nathansuniversity.com/js/jquery-1.7.1.min.js">
  </script>
  <script src=
    "http://nathansuniversity.com/js/chai.js">
  </script>
  <script src="http://nathansuniversity.com/js/mocha.js">
  </script>
  <script src="../parser.js">
  </script>
  <script>mocha.setup('tdd')</script>
  <script>
var expect = chai.expect;    
var assert = chai.assert;

var check = function(condition, errorDetails) {
	if (!condition) {
		throw new Error(errorDetails);
	}
};

// An implementation of evalScheem
var evalScheem = function (expr, env) {
    // Numbers evaluate to themselves
    if (typeof expr === 'number') {
        return expr;
    }
	// Strings are variable references
	if (typeof expr === 'string') {
		check(expr in env, "Unknown variable");
		return env[expr];
	}
    // Look at head of list for operation
    switch (expr[0]) {
        case '+':
			check(expr.length >= 3, "Not enough arguments to '+'");
            return evalScheem(expr[1], env) + evalScheem(expr[2], env);
		case '-':
			check(expr.length >= 3, "Not enough arguments to '-'");
			return evalScheem(expr[1], env) - evalScheem(expr[2], env);
        case '*':
			check(expr.length >= 3, "Not enough arguments to '*'");
            return evalScheem(expr[1], env) * evalScheem(expr[2], env);
		case '/':
			check(expr.length === 3, "Incorrect arguments to '/'");
			return evalScheem(expr[1], env) / evalScheem(expr[2], env);

        case 'quote':
			check(expr.length === 2, "Too many arguments to quote. Expect 1");
            return expr[1];

		case 'define':
			check(expr.length === 3, "Incorrect arguments to 'define'. Expect 2");
			check(typeof expr[1] === 'string', "Trying to define not a variable");
			check(!(expr[1] in env), "Cannot redefine a variable");
			env[expr[1]] = evalScheem(expr[2], env);
			return 0;
		case 'set!':
			check(expr.length === 3, "Incorrect arguments to 'set!'. Expect 2");
			check(expr[1] in env, "Trying to set unknown variable");
			// no need to check if expr[1] is variable because we shouldn't have it in env in the first place
			env[expr[1]] = evalScheem(expr[2], env);
			return 0;

		case 'begin':
			check(expr.length > 1, "Not enough arguments to 'begin'");
            var result = 0;
            var i = 1;
            for (i = 1; i < expr.length; i++) {
                result = evalScheem(expr[i], env);
            }
            return result;

		case '=':
			check(expr.length === 3, "Incorrect arguments to '='. Expect 2");
            var eq = (evalScheem(expr[1], env) === evalScheem(expr[2], env));
            if (eq) return '#t';
            return '#f';
		case '<':
			check(expr.length === 3, "Incorrect arguments to '<'. Expect 2");
            var less = (evalScheem(expr[1], env) < evalScheem(expr[2], env));
            if (less) return '#t';
            return '#f';

		case 'cons':
			check(expr.length === 3, "Incorrect arguments to 'cons'. Expect 2");
            var head = evalScheem(expr[1], env);
            var rest = evalScheem(expr[2], env);
            return [head].concat(rest);
        case 'car':
			check(expr.length === 2, "Incorrect arguments to 'car'. Expect 1");
			var argument = evalScheem(expr[1], env);
			check((typeof argument != 'number') && (typeof argument != 'string'),
				"Can 'car' only a list");
			check(argument.length > 0, "Can 'car' only non-empty list");
			return argument[0];
        case 'cdr':
			check(expr.length === 2, "Incorrect arguments to 'cdr'. Expect 1");
            var result = evalScheem(expr[1], env);
			check((typeof result != 'number') && (typeof result != 'string'),
				"Can 'cdr' only a list");
            result.shift();
            return result;			

		case 'if':
			check(expr.length === 4, "Incorrect arguments to 'if'. Expect 3");
            var condition = evalScheem(expr[1], env);
            var result = 0;
            if (condition === '#t') {
                result = evalScheem(expr[2], env);
            } else if (condition === '#f') {
                result = evalScheem(expr[3], env);
			} else {
				check(false, "Encountered not a boolean in boolean 'if' context");
			}
            return result;			
    }
};

// Some unit tests
suite('evalScheem', function() {
suite('arithmetic', function() {
	test('number', function() {
		assert.deepEqual(
			evalScheem(3, {}),
			3
		);
	});
    test('add two numbers', function() {
        assert.deepEqual(
            evalScheem(['+', 3, 5], {}),
            8
        );
    });
    test('add two other numbers', function() {
        assert.deepEqual(
            evalScheem(['+', 2, 2], {}),
            4
        );
    });
    test('add a number and an expression', function() {
        assert.deepEqual(
            evalScheem(['+', 3, ['+', 2, 2]], {}),
            7
        );
    });
	test('subtraction', function() {
		assert.deepEqual(
			evalScheem(['-', 7, 5], {}),
			2
		);
	});
	test('multiplication', function() {
		assert.deepEqual(
			evalScheem(['*', 2, 3], {}),
			6
		);
	});
	test('division', function() {
		assert.deepEqual(
			evalScheem(['/', 2, 4], {}),
			0.5
		);
	});
	test('complex expression', function() {
		assert.deepEqual(
			evalScheem(['*', ['/', 8, 4], ['+', 1, 1]], {}),
			4
		);
	});
	test('incorrect arguments error', function() {
		assert.throws(function() {
			evalScheem(['+', 2], {});
		});
		assert.throws(function() {
			evalScheem(['-', 2], {});
		});
		assert.throws(function() {
			evalScheem(['*'], {});
		});
		assert.throws(function() {
			evalScheem(['/', 2, 3, 4], {});
		});
	});
});
suite('variables', function() {
	var env = {x:2, y:3, z:10};
	test('single variable', function() {
		assert.deepEqual(
			evalScheem('x', env),
			2
		);
	});
	test('unknown variable error', function() {
		assert.throws(function() {
			evalScheem('x', {});
		});
	});
	test('arithmetic with variable', function() {
		assert.deepEqual(
			evalScheem(['*', 'y', 3], env),
			9
		);
	});
	test('complex expression with variables', function() {
		assert.deepEqual(
			evalScheem(['/', 'z', ['+', 'x', 'y']], env),
			2
		);
	});
	test('define variable', function() {
		var mutableEnv = {};
		evalScheem(['define', 'a', 5], mutableEnv);
		assert.deepEqual(mutableEnv, {a:5});
	});
	test('incorrect arguments to define error', function() {
		assert.throws(function() {
			evalScheem(['define', 'a'], {});
		});
		assert.throws(function() {
			evalScheem(['define', 'a', 5, 7], {});
		});
	});
	test('define not a variable error', function() {
		assert.throws(function() {
			evalScheem(['define', 2, 3], {});
		});
	});
	test('redefine variable error', function() {
		assert.throws(function() {
			evalScheem(['define', 'a', 5], {a:3});
		});
	});
	test('set variable', function() {
		var mutableEnv = {a:5};
		evalScheem(['set!', 'a', 1], mutableEnv);
		assert.deepEqual(mutableEnv, {a:1});
	});
	test('incorrect arguments to set! error', function() {
		assert.throws(function() {
			evalScheem(['set!', 'a'], {a:2});
		});
		assert.throws(function() {
			evalScheem(['set!', 'a', 3, 7], {a:2});
		});
	});
	test('set unknown variable error', function() {
		assert.throws(function() {
			evalScheem(['set!', 'a', 1], {});
		});
	});
	test('set variable to arithmetic expression', function() {
		var mutableEnv = {x:7, y:3, a:2};
		evalScheem(['set!', 'y', ['+', 'x', 1]], mutableEnv);
		assert.deepEqual(mutableEnv, {x:7, y:8, a:2});
	});
});
suite('quote', function() {
    test('a number', function() {
        assert.deepEqual(
            evalScheem(['quote', 3], {}),
            3
        );
    });
    test('an atom', function() {
        assert.deepEqual(
            evalScheem(['quote', 'dog'], {}),
            'dog'
        );
    });
    test('a list', function() {
        assert.deepEqual(
            evalScheem(['quote', [1, 2, 3]], {}),
            [1, 2, 3]
        );
    });
	test('too many arguments error', function() {
		assert.throws(function() {
			evalScheem(['quote', [1, 2], [3, 4]], {});
		});
	});
});
suite('begin', function() {
	test('simple numbers', function() {
		assert.deepEqual(
			evalScheem(['begin', 1, 2, 3], {}),
			3
		);
	});
	test('with arithmetic', function() {
		assert.deepEqual(
			evalScheem(['begin', ['+', 2, 2]], {}),
			4
		);
	});
	test('with variables', function() {
		assert.deepEqual(
			evalScheem(['begin', 'x', 'y', 'x'], {x:1, y:2}),
			1
		);
	});
	test('with setting variable(s)', function() {
		assert.deepEqual(
			evalScheem(['begin',
						['set!', 'x', 5],
						['set!', 'x', ['+', 'y', 'x']],
						'x'], {x:1, y:2}),
			7
		);
	});
	test('not enough arguments error', function() {
		assert.throws(function() {
			evalScheem(['begin'], {});
		});
	});
});
suite('comparison operators', function() {
	test('equal', function() {
		assert.deepEqual(
			evalScheem(['=', 2, 2], {}),
			'#t'
		);
		assert.deepEqual(
			evalScheem(['=', 2, 3], {}),
			'#f'
		);
		assert.deepEqual(
			evalScheem(['=', ['+', 5, 1], ['*', 2, 3]], {}),
			'#t'
		);
	});
	test('less', function() {
		assert.deepEqual(
			evalScheem(['<', 2, 2], {}),
			'#f'
		);
		assert.deepEqual(
			evalScheem(['<', 2, 3], {}),
			'#t'
		);
		assert.deepEqual(
			evalScheem(['<', ['+', 1, 1], ['+', 2, 3]], {}),
			'#t'
		);
	});
	test('incorrect arguments error', function() {
		assert.throws(function() {
			evalScheem(['=', 1], {});
		});
		assert.throws(function() {
			evalScheem(['=', 1, 1, 2], {});
		});
		assert.throws(function() {
			evalScheem(['<', 1], {});
		});
		assert.throws(function() {
			evalScheem(['<', 1, 1, 2], {});
		});
	});
});
suite('list operators', function() {
	test('cons', function() {
		assert.deepEqual(
			evalScheem(['cons', 1, ['quote', [2, 3]]], {}),
			[1, 2, 3]
		);
	});
	test('cons 2 numbers', function() {
		assert.deepEqual(
			evalScheem(['cons', 1, 2], {}),
			[1, 2]
		);
	});
	test('cons list', function() {
		assert.deepEqual(
			evalScheem(['cons', ['quote', [1, 2]], ['quote', [3, 4]]], {}),
			[[1, 2], 3, 4]
		);
	});
	test('car', function() {
		assert.deepEqual(
			evalScheem(['car', ['quote', [[1, 2], 3, 4]]], {}),
			[1, 2]
		);
		assert.deepEqual(
			evalScheem(['car', 'x'], {x:[4, 2]}),
			4
		);
	});
	test('cdr', function() {
		assert.deepEqual(
			evalScheem(['cdr', ['quote', [[1, 2], 3, 4]]], {}),
			[3, 4]
		);
	});
	test('incorrect arguments count error', function() {
		assert.throws(function() {
			evalScheem(['cons', 1, 2, 3], {});
		});
		assert.throws(function() {
			evalScheem(['car', ['quote', [1, 2]], ['quote', [3]]], {});
		});
		assert.throws(function() {
			evalScheem(['cdr', ['quote', [1, 2]], ['quote', [3]]], {});
		});
	});
	test('car/cdr not a list error', function() {
		assert.throws(function() {
			evalScheem(['car', 2], {});
		});
		assert.throws(function() {
			evalScheem(['cdr', 'x'], {x:7});
		});
	});
	test('car empty list error', function() {
		assert.throws(function() {
			evalScheem(['car', ['quote', []]], {});
		});
		// though cdr '() is OK
		assert.deepEqual(
			evalScheem(['cdr', ['quote', []]], {}),
			[]
		);
	});
});
suite('conditionals', function() {
	test('simple if', function() {
		assert.deepEqual(
			evalScheem(['if', ['=', 1, 1], 2, 3], {}),
			2
		);
		assert.deepEqual(
			evalScheem(['if', ['=', 1, 0], 2, 3], {}),
			3
		);
	});
	test('only one if branch is evaluated', function() {
		assert.deepEqual(
			evalScheem(['if', ['=', 1, 1], 2, 'error'], {}),
			2
		);
		assert.deepEqual(
			evalScheem(['if', ['=', 1, 0], 'error', 3], {}),
			3
		);
	});
	test('nested', function() {
		assert.deepEqual(
			evalScheem(['if', ['=', 1, 1], ['if', ['=', 2, 3], 10, 11], 12], {}),
			11
		);
	});
	test('incorrect arguments error', function() {
		assert.throws(function() {
			evalScheem(['if', ['=', 1, 1]], {});
		});
		assert.throws(function() {
			evalScheem(['if', ['=', 1, 1], 2, 3, 4], {});
		});
	});
	test('not a boolean error', function() {
		assert.throws(function() {
			evalScheem(['if', 1, 2, 3], {});
		});
	});
});
});

// Parser unit tests
var parse = SCHEEM.parse;

// Do tests
suite('Grammar', function() {
suite('expression', function() {
    test('empty', function() {
        assert.throws(function() {
            parse("");
        });
    });
    test('atom', function() {
        assert.equal( parse("atom"), "atom" );
    });
    test('integer number', function() {
        assert.deepEqual( parse("13"), 13 );
        assert.deepEqual( parse("012"), 12 ); // octal numbers aren't supported
        assert.deepEqual( parse("-7"), -7 );
        assert.deepEqual( parse("0"), 0 );
        assert.deepEqual( parse("-0"), 0 );
    });
    test('float number', function() {
        assert.deepEqual( parse("4.2"), 4.2 );
        assert.deepEqual( parse("4."), 4.0 );
        assert.deepEqual( parse(".2"), 0.2 );
        assert.deepEqual( parse("-4.2"), -4.2 );
        assert.deepEqual( parse("-4."), -4.0 );
        assert.deepEqual( parse("-.2"), -0.2 );
        assert.deepEqual( parse("0.0"), 0.0 );
        assert.deepEqual( parse("0."), 0.0 );
        assert.deepEqual( parse(".0"), 0.0 );
        assert.deepEqual( parse("-0.0"), 0.0 );
        assert.deepEqual( parse("-0."), 0.0 );
        assert.deepEqual( parse("-.0"), 0.0 );
        // Scientific notation isn't supported
    });
    test('atom with digits and symbols special for numbers', function() {
        assert.deepEqual( parse("y2"), "y2" );
        assert.throws(function() {
            // hexadecimal numbers aren't supported, identifiers cannot start with digit
            parse("0x0BAD1DEA");
        });
        assert.deepEqual( parse("-none-"), "-none-" );
        assert.deepEqual( parse(".dots"), ".dots" );
    });
    test('atom with special symbols', function() {
        assert.equal( parse("+"), "+" );
    });
    test('list', function() {
        assert.deepEqual( parse("(+ x 3)"), ["+", "x", 3] );
    });
    test('nested list', function() {
        assert.deepEqual( parse("(+ 1 (f x 3 y))"),
            ["+", 1, ["f", "x", 3, "y"]] );
    });
    test('single atom in parentheses', function() {
        assert.deepEqual( parse("(x)"), ["x"] );
    });
    test('single atom in nested parentheses', function() {
        assert.deepEqual( parse("((x))"), [["x"]] );
    });
});

suite('whitespace', function() {
    test('2 spaces in atom list', function() {
        assert.deepEqual( parse("(a  b)"), ["a", "b"] );
    });
    test('spaces are required to separate', function() {
        assert.deepEqual( parse("(ab)"), ["ab"] );
    });
    test('spaces around parentheses', function() {
        assert.deepEqual( parse(" ( a b  )"), ["a", "b"] );
    });
    test('tabs', function() {
        assert.deepEqual( parse("(a\tb)"), ["a", "b"] );
    });
    test('newlines', function() {
        assert.deepEqual( parse("(a\nb)"), ["a", "b"] );
    });
    test('tabs and newlines', function() {
        assert.deepEqual( parse(" (a \nb\t )\n"), ["a", "b"] );
    });
});
// XFAIL - vsapsai: don't know how to implement it
//assert.equal( parse(" atom\n"), "atom" );

// -- quote support
suite('quote', function() {
    test('atom', function() {
        assert.deepEqual( parse("'x"), ["quote", "x"] );
    });
    test('list', function() {
        assert.deepEqual( parse("'(a b)"), ["quote", ["a", "b"]] );
    });
    test('quote', function() {
        // this is ridiculous but correct
        assert.deepEqual( parse(" ''x"), ["quote", ["quote", "x"]] );
    });
    test('with space', function() {
        // don't like space between ' and (, but not gonna fight with it
        assert.deepEqual( parse("' (a b)"), ["quote", ["a", "b"]] );
    });
});

// -- comments support
suite('comments', function() {
    test('immediately', function() {
        assert.deepEqual( parse("(a b);;comment"), ["a", "b"] );
    });
    test('whitespace before comment', function() {
        assert.deepEqual( parse("(a b) ;;comment"), ["a", "b"] );
    });
    test('whitespace after comment', function() {
        assert.deepEqual( parse("(+ a ;; comment\n\tb)"), ["+", "a", "b"] );
    });
    test('comment with valid code', function() {
        assert.deepEqual( parse("(a;;b)\nc)"), ["a", "c"] );
    });
});
});

var evalScheemString = function(code, env) {
	return evalScheem(SCHEEM.parse(code), env);
};

suite('evalScheemString', function() {
suite('simple', function() {
	test('complex expression', function() {
		assert.deepEqual(
			evalScheemString('( + x (*    2 y)) ', {x:7, y:3}),
			13
		);
	});
});
});

  </script>
  <script>
    $(function(){
      mocha.run();
    });
  </script>
</head>
<body>
  <div id="mocha"></div>
</body>
</html>
